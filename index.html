<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <title>X eller Y – med datum och veckodag</title>
  <style>
    body { 
      display: flex; 
      flex-direction: column;
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      font-family: Arial, sans-serif; 
      transition: background 1.5s ease;
      background: linear-gradient(135deg, #0BA2F4, #004080);
    }
    .letter { 
      font-size: 15rem;
      font-weight: bold; 
      display: inline-block;
      transition: transform 0.6s ease, opacity 0.6s ease;
      transform-origin: center;
      opacity: 1;
      visibility: hidden;
    }
    .date, .weekday {
      font-size: 4rem;
      font-weight: bold;
      margin-top: 0.5rem;
      opacity: 1;
      visibility: hidden;
      transition: transform 0.6s ease, opacity 0.6s ease;
    }
    .next-workday-text,
    .clock-text,
    .countdown-text {
      font-size: 2rem;
      font-weight: bold;
      text-align: center;
      margin-top: 0.5rem;
      max-width: 90vw;
      opacity: 1;
      visibility: hidden;
      transition: transform 0.6s ease, opacity 0.6s ease;
    }
    .letter, .date, .weekday, .next-workday-text, .clock-text, .countdown-text {
      color: #fff;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="letter" id="letter">X</div>
  <div class="date" id="date">0000-00-00</div>
  <div class="weekday" id="weekday">Veckodag</div>
  <div class="clock-text" id="clock-text">Klockan är 00:00:00</div>
  <div class="next-workday-text" id="next-workday-text">Nästa arbetsdygn...</div>
  <div class="countdown-text" id="countdown-text">Tid kvar...</div>

  <script>
    const startDate = new Date("2025-01-02");
    let holidays = [];
    const TIME_SYNC_INTERVAL = 5 * 60 * 1000;

    let currentTime = null;
    let lastSync = 0;

    const localHolidays = [
      "2025-01-01","2025-01-06","2025-04-18","2025-04-20","2025-04-21","2025-05-01","2025-05-29","2025-06-06",
      "2025-06-20","2025-06-21","2025-11-01","2025-12-24","2025-12-25","2025-12-26","2025-12-31",
      "2026-01-01","2026-01-06","2026-04-03","2026-04-05","2026-04-06","2026-05-01","2026-05-14","2026-05-24","2026-06-06",
      "2026-06-19","2026-06-20","2026-10-31","2026-11-01","2026-12-24","2026-12-25","2026-12-26","2026-12-31",
      "2027-01-01","2027-01-06","2027-04-02","2027-04-04","2027-04-05","2027-05-01","2027-05-13","2027-05-23","2027-06-06",
      "2027-06-25","2027-06-26","2027-10-30","2027-11-01","2027-12-24","2027-12-25","2027-12-26","2027-12-31",
      "2028-01-01","2028-01-06","2028-04-14","2028-04-16","2028-04-17","2028-05-01","2028-05-25","2028-06-04","2028-06-06",
      "2028-06-23","2028-06-24","2028-10-28","2028-12-24","2028-12-25","2028-12-26","2028-12-31",
      "2029-01-01","2029-01-06","2029-03-30","2029-04-01","2029-04-02","2029-05-01","2029-05-10","2029-05-20","2029-06-06",
      "2029-06-22","2029-06-23","2029-11-03","2029-12-24","2029-12-25","2029-12-26","2029-12-31"
    ];

    async function fetchHolidays(year) {
      try {
        const res = await fetch(`https://api.dagsmart.se/holidays?year=${year}&weekends=false`);
        if (!res.ok) throw new Error("Fel vid hämtning av helgdagar från API");
        const data = await res.json();
        return data.map(h => h.date);
      } catch (err) {
        console.warn("API saknas, fallback till lokal lista:", err);
        return localHolidays.filter(d => d.startsWith(String(year)));
      }
    }

    async function getSwedishTime() {
      const API_KEY = "40O5JW280XZE";
      const url = `https://api.timezonedb.com/v2.1/get-time-zone?key=${API_KEY}&format=json&by=zone&zone=Europe/Stockholm`;
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP fel: ${res.status}`);
        const data = await res.json();
        return new Date(data.formatted);
      } catch (err) {
        console.warn("Fallback till lokal tid:", err);
        return new Date();
      }
    }

    async function loadHolidays() {
      const thisYear = new Date().getFullYear();
      const nextYear = thisYear + 1;
      const [h1, h2] = await Promise.all([fetchHolidays(thisYear), fetchHolidays(nextYear)]);
      holidays = [...h1, ...h2];
    }

    function isValidWorkday(date) {
      const day = date.getDay();
      const str = date.toISOString().split("T")[0];
      if (day === 0 || day === 6) return false;
      if (holidays.includes(str)) return false;
      if (date.getMonth() === 11 && (date.getDate() === 24 || date.getDate() === 31)) return false;
      return true;
    }

    function countWorkdays(from, to) {
      let count = 0;
      const cur = new Date(from);
      while (cur <= to) {
        if (isValidWorkday(cur)) count++;
        cur.setDate(cur.getDate() + 1);
      }
      return count;
    }

    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    let currentLetter = null;

    async function displayLetter(doFlip = true) {
      let now = await getSwedishTime();
      let workdayCheck = new Date(now);
      if (workdayCheck.getHours() < 5 || (workdayCheck.getHours() === 5 && workdayCheck.getMinutes() < 30)) {
        workdayCheck.setDate(workdayCheck.getDate() - 1);
      }

      if (holidays.length === 0) await loadHolidays();

      let refDate = new Date(workdayCheck);
      refDate.setHours(0,0,0,0);
      while (!isValidWorkday(refDate) && refDate >= startDate) {
        refDate.setDate(refDate.getDate() - 1);
      }

      const count = countWorkdays(startDate, refDate);
      const letter = (count % 2 === 0) ? "X" : "Y";

      const letterEl = document.getElementById("letter");
      document.body.style.background = (letter === "X") 
        ? "linear-gradient(135deg, #0BA2F4, #004080)"
        : "linear-gradient(135deg, #27F584, #008040)";

      if (doFlip || letter !== currentLetter) {
        letterEl.style.transform = "rotateY(90deg)";
        letterEl.style.opacity = 0;
        setTimeout(() => {
          letterEl.textContent = letter;
          letterEl.style.transform = "rotateY(0deg)";
          letterEl.style.opacity = 1;
          letterEl.style.visibility = "visible";
          document.querySelectorAll(".date, .weekday, .next-workday-text, .clock-text, .countdown-text")
            .forEach(el => el.style.visibility = "visible");
        }, 600);
      } else {
        letterEl.textContent = letter;
      }

      currentLetter = letter;

      const yyyyRef = refDate.getFullYear();
      const mmRef = String(refDate.getMonth() + 1).padStart(2, "0");
      const ddRef = String(refDate.getDate()).padStart(2, "0");
      document.getElementById("date").textContent = `${yyyyRef}-${mmRef}-${ddRef}`;
      document.getElementById("weekday").textContent = capitalize(refDate.toLocaleDateString('sv-SE', { weekday: 'long' }));
    }

    function getNextWorkdayStart(now) {
      let next = new Date(now);
      next.setHours(5,30,0,0);
      if (now >= next) next.setDate(next.getDate() + 1);
      while (!isValidWorkday(next)) {
        next.setDate(next.getDate() + 1);
        next.setHours(5,30,0,0);
      }
      return next;
    }

    async function updateClockAndCountdown() {
      const nowMs = Date.now();
      if (!currentTime || nowMs - lastSync > TIME_SYNC_INTERVAL) {
        currentTime = await getSwedishTime();
        lastSync = nowMs;
      } else {
        currentTime = new Date(currentTime.getTime() + 1000);
      }
      let now = currentTime;
      let nextWorkday = getNextWorkdayStart(now);

      const yyyy = nextWorkday.getFullYear();
      const mm = String(nextWorkday.getMonth() + 1).padStart(2,"0");
      const dd = String(nextWorkday.getDate()).padStart(2,"0");
      const weekday = nextWorkday.toLocaleDateString("sv-SE", { weekday: "long" });

      document.getElementById("next-workday-text").textContent = `Nästa arbetsdygn börjar ${weekday} ${yyyy}-${mm}-${dd} 05:30`;

      document.getElementById("clock-text").textContent = `Klockan är nu ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}`;

      const diff = nextWorkday - now;
      document.getElementById("countdown-text").textContent = `Tid kvar till nästa arbetsdygn ${String(Math.floor(diff / (1000*60*60)).toString().padStart(2,'0'))}:${String(Math.floor((diff/1000/60)%60).toString().padStart(2,'0'))}:${String(Math.floor((diff/1000)%60).toString().padStart(2,'0'))}`;
    }

    async function scheduleLetterUpdate() {
      const now = await getSwedishTime();
      const next = getNextWorkdayStart(now);
      const msUntilNext = Math.max(next - now, 0);

      setTimeout(async () => {
        await displayLetter(true);
        scheduleLetterUpdate();
      }, msUntilNext);
    }

    // Starta uppdateringarna
    setInterval(() => displayLetter(false), 60000);
    displayLetter(true);
    scheduleLetterUpdate();
    setInterval(updateClockAndCountdown, 1000);
  </script>
</body>
</html>
